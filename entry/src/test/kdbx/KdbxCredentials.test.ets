/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, beforeAll, beforeEach, afterEach, afterAll, it, expect } from '@ohos/hypium';
import { KdbxCredentials, KeyFileFormat } from '../../../main/ets/kdbx/KdbxCredentials';
import util from '@ohos.util';
import { KdbxUtils } from '../../main/ets/kdbx/utils/KdbxUtils';

describe('KdbxCredentials', () => {
  let credentials: KdbxCredentials;

  beforeAll(() => {
    // æµ‹è¯•å¥—ä»¶å¼€å§‹å‰çš„è®¾ç½®
  });

  beforeEach(() => {
    // æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å¼€å§‹å‰çš„è®¾ç½®
    credentials = new KdbxCredentials();
  });

  afterEach(() => {
    // æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç»“æŸåçš„æ¸…ç†
    credentials.clear();
  });

  afterAll(() => {
    // æµ‹è¯•å¥—ä»¶ç»“æŸåçš„æ¸…ç†
  });

  it('should handle password credentials', async () => {
    const password = 'testPassword123';
    credentials.setPassword(password);

    expect(credentials.isValid()).assertEqual(true);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32); // SHA-256è¾“å‡ºé•¿åº¦

    // éªŒè¯ç›¸åŒå¯†ç ç”Ÿæˆç›¸åŒçš„å¯†é’¥
    const credentials2 = new KdbxCredentials();
    credentials2.setPassword(password);
    const compositeKey2 = await credentials2.getCompositeKey();
    expect(compositeKey).toEqual(compositeKey2);
  });

  it('should handle key file in XML format', async () => {
    // ç”ŸæˆXMLæ ¼å¼çš„å¯†é’¥æ–‡ä»¶
    const keyFileData = await KdbxCredentials.generateKeyFile(KeyFileFormat.XML);
    expect(keyFileData).toBeDefined();

    // éªŒè¯ç”Ÿæˆçš„XMLæ ¼å¼
    const xmlString = new util.TextDecoder().decode(keyFileData);
    expect(xmlString).toContain('<?xml version="1.0" encoding="utf-8"?>');
    expect(xmlString).toContain('<KeyFile>');
    expect(xmlString).toContain('<Version>2.0</Version>');
    expect(xmlString).toContain('<Data>');

    // ä½¿ç”¨ç”Ÿæˆçš„å¯†é’¥æ–‡ä»¶
    credentials.setKeyFileData(keyFileData);
    expect(credentials.isValid()).assertEqual(true);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);
  });

  it('should handle key file in binary format', async () => {
    // ç”ŸæˆäºŒè¿›åˆ¶æ ¼å¼çš„å¯†é’¥æ–‡ä»¶
    const keyFileData = await KdbxCredentials.generateKeyFile(KeyFileFormat.BINARY);
    expect(keyFileData).toBeDefined();
    expect(keyFileData.length).assertEqual(32);

    // ä½¿ç”¨ç”Ÿæˆçš„å¯†é’¥æ–‡ä»¶
    credentials.setKeyFileData(keyFileData);
    expect(credentials.isValid()).assertEqual(true);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);
  });

  it('should handle key file in hex format', async () => {
    // ç”Ÿæˆåå…­è¿›åˆ¶æ ¼å¼çš„å¯†é’¥æ–‡ä»¶
    const keyFileData = await KdbxCredentials.generateKeyFile(KeyFileFormat.HEX);
    expect(keyFileData).toBeDefined();

    // éªŒè¯ç”Ÿæˆçš„åå…­è¿›åˆ¶æ ¼å¼
    const hexString = new util.TextDecoder().decode(keyFileData);
    expect(hexString.length).assertEqual(64);
    expect(/^[0-9A-Fa-f]{64}$/.test(hexString)).assertEqual(true);

    // ä½¿ç”¨ç”Ÿæˆçš„å¯†é’¥æ–‡ä»¶
    credentials.setKeyFileData(keyFileData);
    expect(credentials.isValid()).assertEqual(true);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);
  });

  it('should handle Windows user account data', async () => {
    // æ¨¡æ‹ŸWindowsç”¨æˆ·è´¦æˆ·æ•°æ®
    const userData =KdbxUtils.generateRandom(new Uint8Array(32));
    credentials.setWindowsUserData(userData);

    expect(credentials.isValid()).assertEqual(true);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);

    // éªŒè¯ç›¸åŒç”¨æˆ·æ•°æ®ç”Ÿæˆç›¸åŒçš„å¯†é’¥
    const credentials2 = new KdbxCredentials();
    credentials2.setWindowsUserData(userData);
    const compositeKey2 = await credentials2.getCompositeKey();
    expect(compositeKey).toEqual(compositeKey2);
  });

  it('should combine multiple credentials', async () => {
    const password = 'testPassword123';
    const keyFileData = await KdbxCredentials.generateKeyFile(KeyFileFormat.BINARY);
    const userData = KdbxUtils.generateRandom(new Uint8Array(32));

    // è®¾ç½®æ‰€æœ‰å‡­è¯
    credentials.setPassword(password);
    credentials.setKeyFileData(keyFileData);
    credentials.setWindowsUserData(userData);

    expect(credentials.isValid()).assertEqual(true);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);

    // éªŒè¯ç›¸åŒå‡­è¯ç»„åˆç”Ÿæˆç›¸åŒçš„å¯†é’¥
    const credentials2 = new KdbxCredentials();
    credentials2.setPassword(password);
    credentials2.setKeyFileData(keyFileData);
    credentials2.setWindowsUserData(userData);
    const compositeKey2 = await credentials2.getCompositeKey();
    expect(compositeKey).toEqual(compositeKey2);
  });

  it('should clear credentials', () => {
    credentials.setPassword('testPassword');
    credentials.setKeyFileData(new Uint8Array(32));
    credentials.setWindowsUserData(new Uint8Array(32));

    expect(credentials.isValid()).assertEqual(true);

    credentials.clear();
    expect(credentials.isValid()).assertEqual(false);
  });

  it('should validate credentials', () => {
    expect(credentials.isValid()).assertEqual(false);

    credentials.setPassword('testPassword');
    expect(credentials.isValid()).assertEqual(true);

    credentials.clear();
    expect(credentials.isValid()).assertEqual(false);

    credentials.setKeyFileData(new Uint8Array(32));
    expect(credentials.isValid()).assertEqual(true);

    credentials.clear();
    expect(credentials.isValid()).assertEqual(false);

    credentials.setWindowsUserData(new Uint8Array(32));
    expect(credentials.isValid()).assertEqual(true);
  });

  it('should handle empty credentials', async () => {
    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);
    expect(new Set(compositeKey).size).assertEqual(1); // åº”è¯¥å…¨æ˜¯0
  });

  it('should handle invalid key file formats', async () => {
    // æµ‹è¯•æ— æ•ˆçš„XML
    const invalidXml = new util.TextEncoder().encode('<invalid>XML</data>');
    credentials.setKeyFileData(invalidXml);
    const compositeKey1 = await credentials.getCompositeKey();
    expect(compositeKey1.length).assertEqual(32);

    // æµ‹è¯•æ— æ•ˆçš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²
    const invalidHex = new util.TextEncoder().encode('NotHexString');
    credentials.setKeyFileData(invalidHex);
    const compositeKey2 = await credentials.getCompositeKey();
    expect(compositeKey2.length).assertEqual(32);

    // æµ‹è¯•æ— æ•ˆé•¿åº¦çš„äºŒè¿›åˆ¶æ•°æ®
    const invalidBinary = new Uint8Array(16); // ä¸æ˜¯32å­—èŠ‚
    credentials.setKeyFileData(invalidBinary);
    const compositeKey3 = await credentials.getCompositeKey();
    expect(compositeKey3.length).assertEqual(32);
  });

  it('should handle special characters in password', async () => {
    const specialPassword = '!@#$%^&*()_+{}|:"<>?~`-=[]\\;\',./';
    credentials.setPassword(specialPassword);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);

    // éªŒè¯ç›¸åŒå¯†ç ç”Ÿæˆç›¸åŒçš„å¯†é’¥
    const credentials2 = new KdbxCredentials();
    credentials2.setPassword(specialPassword);
    const compositeKey2 = await credentials2.getCompositeKey();
    expect(compositeKey).toEqual(compositeKey2);
  });

  it('should handle Unicode passwords', async () => {
    const unicodePassword = 'å¯†ç æµ‹è¯•ğŸ”‘';
    credentials.setPassword(unicodePassword);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);

    // éªŒè¯ç›¸åŒå¯†ç ç”Ÿæˆç›¸åŒçš„å¯†é’¥
    const credentials2 = new KdbxCredentials();
    credentials2.setPassword(unicodePassword);
    const compositeKey2 = await credentials2.getCompositeKey();
    expect(compositeKey).toEqual(compositeKey2);
  });

  it('should handle large key files', async () => {
    // åˆ›å»º1MBçš„éšæœºæ•°æ®
    const largeKeyFile = KdbxUtils.generateRandom(new Uint8Array(1024 * 1024));
    credentials.setKeyFileData(largeKeyFile);

    const compositeKey = await credentials.getCompositeKey();
    expect(compositeKey).toBeDefined();
    expect(compositeKey.length).assertEqual(32);

    // éªŒè¯ç›¸åŒæ•°æ®ç”Ÿæˆç›¸åŒçš„å¯†é’¥
    const credentials2 = new KdbxCredentials();
    credentials2.setKeyFileData(largeKeyFile);
    const compositeKey2 = await credentials2.getCompositeKey();
    expect(compositeKey).toEqual(compositeKey2);
  });

  it('should maintain constant time operations', async () => {
    const password1 = 'password1';
    const password2 = 'password2';

    // è®°å½•ä¸¤æ¬¡æ“ä½œçš„æ—¶é—´
    const start1 = Date.now();
    credentials.setPassword(password1);
    await credentials.getCompositeKey();
    const time1 = Date.now() - start1;

    const start2 = Date.now();
    credentials.setPassword(password2);
    await credentials.getCompositeKey();
    const time2 = Date.now() - start2;

    // éªŒè¯æ—¶é—´å·®å¼‚ä¸å¤§ï¼ˆå…è®¸10%çš„è¯¯å·®ï¼‰
    const timeDiff = Math.abs(time1 - time2);
    expect(timeDiff / Math.max(time1, time2)).toBeLessThan(0.1);
  });
});
